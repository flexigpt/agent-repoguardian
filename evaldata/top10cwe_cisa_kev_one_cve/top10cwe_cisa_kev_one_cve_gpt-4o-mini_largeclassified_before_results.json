[
  {
    "id": "CVE-2024-27918",
    "scan_type": "before",
    "scan_responses": [
      {
        "code_block": {
          "categorized_lines": [
            {
              "Primary Functional Area": "Security and Access Control",
              "Sub Functional Area": "Authorization",
              "Example issues to look for": [
                "Excessive Attack Surface",
                "Insufficient Granularity of Access Control",
                "Binding to an Unrestricted IP Address",
                "Obscured Security-relevant Information by Alternate Name",
                "Creation of chroot Jail Without Changing Working Directory",
                "Unverified Ownership",
                "Improperly Implemented Security Check for Standard",
                "Trust of System Event Data",
                "Passing Mutable Objects to an Untrusted Method",
                "Returning a Mutable Object to an Untrusted Caller",
                "Direct Request ('Forced Browsing')",
                "Incomplete Model of Endpoint Features",
                "External Initialization of Trusted Variables or Data Stores",
                "Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')",
                "External Control of Assumed-Immutable Web Parameter",
                "Trust Boundary Violation",
                "Incorrect Behavior Order: Authorization Before Parsing and Canonicalization",
                "Authorization Bypass Through User-Controlled Key",
                "Improper Isolation or Compartmentalization",
                "Reliance on Security Through Obscurity",
                "Incorrect Ownership Assignment",
                "Reliance on Untrusted Inputs in a Security Decision",
                "Inclusion of Functionality from Untrusted Control Sphere",
                "Improper Enforcement of a Single, Unique Action",
                "Placement of User into Incorrect Group",
                "Improperly Controlled Modification of Dynamically-Determined Object Attributes",
                "Server-Side Request Forgery (SSRF)",
                "Improper Authorization in Handler for Custom URL Scheme"
              ],
              "Code lines": [
                "ok = false",
                "for _, domain := range api.OIDCConfig.EmailDomain {",
                "if strings.HasSuffix(strings.ToLower(email), strings.ToLower(domain)) {",
                "ok = true",
                "break",
                "}",
                "}",
                "if !ok {",
                "httpapi.Write(ctx, rw, http.StatusForbidden, codersdk.Response{",
                "Message: fmt.Sprintf(\"Your email %q is not in domains %q !\", email, api.OIDCConfig.EmailDomain),",
                "})",
                "return",
                "}",
                "Filename: coderd/userauth.go"
              ]
            },
            {
              "Primary Functional Area": "Data Management and Integrity",
              "Sub Functional Area": "Data Validation",
              "Example issues to look for": [
                "Misinterpretation of Input",
                "Improper Use of Validation Framework",
                "Improper Validation of Unsafe Equivalence in Input",
                "Incorrect Parsing of Numbers with Different Radices",
                "Improper Handling of Missing Special Element",
                "Improper Handling of Additional Special Element",
                "Improper Handling of Inconsistent Special Elements",
                "Improper Handling of Case Sensitivity",
                "Incorrect Behavior Order: Early Validation",
                "Improper Handling of Values",
                "Improper Handling of Parameters",
                "Unchecked Input for Loop Condition"
              ],
              "Code lines": [
                "ok = false",
                "for _, domain := range api.OIDCConfig.EmailDomain {",
                "if strings.HasSuffix(strings.ToLower(email), strings.ToLower(domain)) {",
                "ok = true",
                "break",
                "}",
                "}",
                "if !ok {",
                "httpapi.Write(ctx, rw, http.StatusForbidden, codersdk.Response{",
                "Message: fmt.Sprintf(\"Your email %q is not in domains %q !\", email, api.OIDCConfig.EmailDomain),",
                "})",
                "return",
                "}",
                "Filename: coderd/userauth.go"
              ]
            }
          ]
        },
        "scan_response": {
          "vuln_score": 6,
          "exploitable_vuln": true,
          "description": "The code checks if an email belongs to a specific domain but does not validate the format of the email itself. This could lead to improper handling of malicious input, such as injection attacks. Additionally, the use of 'strings.ToLower' for domain comparison may not account for all edge cases, such as internationalized domain names. The lack of comprehensive validation makes this a potential security risk."
        }
      }
    ]
  },
  {
    "id": "CVE-2024-31457",
    "scan_type": "before",
    "scan_responses": [
      {
        "code_block": {
          "categorized_lines": [
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Expression Issues",
              "Example issues to look for": [
                "Processor Optimization Removal or Modification of Security-critical Code",
                "Excessive Use of Self-Modifying Code",
                "Missing Default Case in Multiple Condition Expression",
                "Use of Incorrect Operator",
                "Incorrect Block Delimitation",
                "Omitted Break Statement in Switch",
                "Reachable Assertion",
                "Executable Regular Expression Error",
                "Permissive Regular Expression",
                "Compiler Optimization Removal or Modification of Security-critical Code",
                "Operator Precedence Logic Error",
                "Loop with Unreachable Exit Condition ('Infinite Loop')"
              ],
              "Code lines": [
                "return",
                "}"
              ]
            },
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Data / Function Handling",
              "Example issues to look for": [
                "Invokable Control Element with Excessive File or Data Access Operations",
                "Reliance on Runtime Component in Generated Code",
                "Use of Inherently Dangerous Function",
                "Symbolic Name not Mapping to Correct Object",
                "Use of NullPointerException Catch to Detect NULL Pointer Dereference",
                "Deployment of Wrong Handler",
                "Missing Handler",
                "Use of Function with Inconsistent Implementations",
                "Undefined Behavior for Input to API",
                "Use of Obsolete Function",
                "Exposed Dangerous Method or Function",
                "Improper Control of Generation of Code ('Code Injection')"
              ],
              "Code lines": [
                "a.NeedModel = a.HasRequest || a.HasResponse",
                "err = autoCodeService.CreatePlug(a)"
              ]
            }
          ]
        },
        "scan_response": {
          "vuln_score": 6,
          "exploitable_vuln": false,
          "description": "The code contains potential issues related to data handling and expression management. Specifically, the line 'a.NeedModel = a.HasRequest || a.HasResponse' could lead to undefined behavior if 'a' is not properly initialized or if 'HasRequest' and 'HasResponse' are not boolean values. Additionally, the return statement without a value and the closing brace '}' indicate incomplete control flow, which could lead to logical errors. However, these issues do not present a direct exploitable vulnerability as they do not allow for an attacker to manipulate the system or gain unauthorized access. To mitigate these concerns, ensure proper initialization of variables and complete control flow structures."
        }
      }
    ]
  },
  {
    "id": "CVE-2014-125026",
    "scan_type": "before",
    "scan_responses": [
      {
        "code_block": {
          "categorized_lines": [
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Data / Function Handling",
              "Example issues to look for": [
                "Invokable Control Element with Excessive File or Data Access Operations",
                "Reliance on Runtime Component in Generated Code",
                "Use of Inherently Dangerous Function",
                "Symbolic Name not Mapping to Correct Object",
                "Use of NullPointerException Catch to Detect NULL Pointer Dereference",
                "Deployment of Wrong Handler",
                "Missing Handler",
                "Use of Function with Inconsistent Implementations",
                "Undefined Behavior for Input to API",
                "Use of Obsolete Function",
                "Exposed Dangerous Method or Function",
                "Improper Control of Generation of Code ('Code Injection')"
              ],
              "Code lines": [
                "read := int(C.LZ4_uncompress(p(in), p(out), clen(out)))",
                "if read != len(in) {",
                "err = fmt.Errorf(\"uncompress read %d bytes should have read %d\",",
                "read, len(in))",
                "}",
                "return",
                "}",
                "// CompressBound calculates the size of the output buffer needed by"
              ]
            },
            {
              "Primary Functional Area": "Data Management and Integrity",
              "Sub Functional Area": "Data Processing",
              "Example issues to look for": [
                "Data Element Aggregating an Excessively Large Number of Non-Primitive Elements",
                "Excessive Data Query Operations in a Large Data Table",
                "Missing Serialization Control Element",
                "Excessive Execution of Sequential Searches of Data Resource",
                "Data Resource Access without Use of Connection Pooling",
                "Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses",
                "Excessive Index Range Scan for a Data Resource",
                "Reliance on Machine-Dependent Data Representation",
                "Missing XML Validation",
                "Improper Handling of Length Parameter Inconsistency",
                "Collapse of Data into Unsafe Value",
                "Improper Handling of Structural Elements",
                "Acceptance of Extraneous Untrusted Data With Trusted Data",
                "Improper Handling of Highly Compressed Data (Data Amplification)",
                "Deserialization of Untrusted Data",
                "Dangling Database Cursor ('Cursor Injection')"
              ],
              "Code lines": [
                "read := int(C.LZ4_uncompress(p(in), p(out), clen(out)))",
                "if read != len(in) {",
                "err = fmt.Errorf(\"uncompress read %d bytes should have read %d\",",
                "read, len(in))",
                "}",
                "return",
                "}",
                "// CompressBound calculates the size of the output buffer needed by"
              ]
            }
          ]
        },
        "scan_response": {
          "vuln_score": 6,
          "exploitable_vuln": true,
          "description": "The code contains a potential vulnerability related to the use of the LZ4_uncompress function. If the input data (in) is not properly validated, it could lead to a buffer overflow or memory corruption, especially if the compressed data is larger than expected. The check for the read length against the input length is present, but if the input is manipulated or malformed, it may still lead to undefined behavior. This is a concern as it can be exploited to execute arbitrary code or crash the application. To mitigate this risk, ensure that input data is validated and sanitized before processing, and consider implementing additional checks for the integrity of the data being decompressed."
        }
      }
    ]
  },
  {
    "id": "CVE-2020-24710",
    "scan_type": "before",
    "scan_responses": [
      {
        "code_block": {
          "categorized_lines": [
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Data / Function Handling",
              "Example issues to look for": [
                "Invokable Control Element with Excessive File or Data Access Operations",
                "Reliance on Runtime Component in Generated Code",
                "Use of Inherently Dangerous Function",
                "Symbolic Name not Mapping to Correct Object",
                "Use of NullPointerException Catch to Detect NULL Pointer Dereference",
                "Deployment of Wrong Handler",
                "Missing Handler",
                "Use of Function with Inconsistent Implementations",
                "Undefined Behavior for Input to API",
                "Use of Obsolete Function",
                "Exposed Dangerous Method or Function",
                "Improper Control of Generation of Code ('Code Injection')"
              ],
              "Code lines": [
                "ListenURL string `json:\"listen_url\"`",
                "UseTLS    bool   `json:\"use_tls\"`",
                "CertPath  string `json:\"cert_path\"`",
                "KeyPath   string `json:\"key_path\"`",
                "CSRFKey   string `json:\"csrf_key\"`",
                "}",
                "ListenURL string `json:\"listen_url\"`",
                "UseTLS    bool   `json:\"use_tls\"`",
                "CertPath  string `json:\"cert_path\"`",
                "KeyPath   string `json:\"key_path\"`",
                "}",
                "AdminConf      AdminServer `json:\"admin_server\"`",
                "PhishConf      PhishServer `json:\"phish_server\"`",
                "DBName         string      `json:\"db_name\"`",
                "DBPath         string      `json:\"db_path\"`",
                "DBSSLCaPath    string      `json:\"db_sslca_path\"`",
                "MigrationsPath string      `json:\"migrations_prefix\"`",
                "TestFlag       bool        `json:\"test_flag\"`",
                "ContactAddress string      `json:\"contact_address\"`",
                "Logging        *log.Config `json:\"logging\"`",
                "}",
                "// Get the config file",
                "if err != nil {",
                "return nil, err",
                "err = json.Unmarshal(configFile, config)",
                "if err != nil {",
                "return nil, err",
                "config.Logging = &log.Config{}",
                "config.MigrationsPath = config.MigrationsPath + config.DBName",
                "return config, nil",
                "}",
                "URL              string `json:\"url\"`",
                "IncludeResources bool   `json:\"include_resources\"`",
                "}",
                "HTML string `json:\"html\"`",
                "}",
                "Text    string `json:\"text\"`",
                "HTML    string `json:\"html\"`",
                "Subject string `json:\"subject\"`",
                "}",
                "ts, err := util.ParseCSV(r)",
                "if err != nil {",
                "JSONResponse(w, models.Response{Success: false, Message: \"Error parsing CSV\"}, http.StatusInternalServerError)",
                "return",
                "}",
                "if r.Method != \"POST\" {",
                "JSONResponse(w, models.Response{Success: false, Message: \"Method not allowed\"}, http.StatusBadRequest)",
                "return",
                "}",
                "Content      string `json:\"content\"`",
                "ConvertLinks bool   `json:\"convert_links\"`",
                "}{}",
                "if err != nil {",
                "return",
                "if err != nil {",
                "log.Error(err)",
                "// If the user wants to convert links to point to",
                "d, err := goquery.NewDocumentFromReader(bytes.NewReader(e.HTML))",
                "if err != nil {",
                "JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)",
                "}",
                "return",
                "}",
                "Subject: e.Subject,",
                "Text:    string(e.Text),",
                "HTML:    string(e.HTML),",
                "}",
                "}",
                "cr := cloneRequest{}",
                "if r.Method != \"POST\" {",
                "JSONResponse(w, models.Response{Success: false, Message: \"Method not allowed\"}, http.StatusBadRequest)",
                "return",
                "err := json.NewDecoder(r.Body).Decode(&cr)",
                "if err != nil {",
                "JSONResponse(w, models.Response{Success: false, Message: \"Error decoding JSON Request\"}, http.StatusBadRequest)",
                "}",
                "JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)",
                "return",
                "TLSClientConfig: &tls.Config{",
                "InsecureSkipVerify: true,",
                "},",
                "resp, err := client.Get(cr.URL)",
                "if err != nil {",
                "return",
                "d, err := goquery.NewDocumentFromResponse(resp)",
                "if err != nil {",
                "return",
                "d.Find(\"head\").PrependHtml(fmt.Sprintf(\"<base href=\\\"%s\\\">\", cr.URL))",
                "}",
                "forms.Each(func(i int, f *goquery.Selection) {",
                "// We'll want to store where we got the form from",
                "if err != nil {",
                "JSONResponse(w, cs, http.StatusOK)",
                "}"
              ]
            },
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Initialization and Cleanup",
              "Example issues to look for": [
                "Initialization of a Resource with an Insecure Default",
                "Non-exit on Failed Initialization"
              ],
              "Code lines": [
                "version, err := ioutil.ReadFile(\"./VERSION\")",
                "if err != nil {",
                "kingpin.Parse()",
                "// Just warn if a contact address hasn't been configured",
                "log.Fatal(err)",
                "log.Warnf(\"No contact address has been configured.\")",
                "if err != nil {",
                "if err != nil {",
                "// when Gophish was last shutdown.",
                "adminOptions := []controllers.AdminServerOption{}",
                "if *disableMailer {",
                "adminServer := controllers.NewAdminServer(adminConfig, adminOptions...)",
                "phishConfig := conf.PhishConf",
                "phishServer := controllers.NewPhishingServer(phishConfig)",
                "if *mode == \"admin\" || *mode == \"all\" {",
                "go adminServer.Start()",
                "go imapMonitor.Start()",
                "if *mode == \"phish\" || *mode == \"all\" {",
                "signal.Notify(c, os.Interrupt)",
                "<-c",
                "if *mode == modeAdmin || *mode == modeAll {",
                "imapMonitor.Shutdown()",
                "}"
              ]
            },
            {
              "Primary Functional Area": "Data Management and Integrity",
              "Sub Functional Area": "Data Validation",
              "Example issues to look for": [
                "Misinterpretation of Input",
                "Improper Use of Validation Framework",
                "Improper Validation of Unsafe Equivalence in Input",
                "Incorrect Parsing of Numbers with Different Radices",
                "Improper Handling of Missing Special Element",
                "Improper Handling of Additional Special Element",
                "Improper Handling of Inconsistent Special Elements",
                "Improper Handling of Case Sensitivity",
                "Incorrect Behavior Order: Early Validation",
                "Improper Handling of Values",
                "Improper Handling of Parameters",
                "Unchecked Input for Loop Condition"
              ],
              "Code lines": [
                "if cr.URL == \"\" {",
                "return errors.New(\"No URL Specified\")",
                "}",
                "}"
              ]
            }
          ]
        },
        "scan_response": {
          "vuln_score": 6,
          "exploitable_vuln": true,
          "description": "The code contains several vulnerabilities related to improper error handling and insecure configurations. Specifically, the use of 'InsecureSkipVerify: true' in the TLS client configuration poses a significant risk as it allows for man-in-the-middle attacks by not verifying the server's certificate. Additionally, the error handling in various places does not provide sufficient feedback or logging, which could lead to undetected issues during runtime. The code also lacks proper validation for user inputs, particularly in the handling of URLs, which could lead to injection attacks or other forms of exploitation. Overall, while there are some safeguards in place, the presence of these vulnerabilities makes the code exploitable."
        }
      },
      {
        "code_block": {
          "categorized_lines": [
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Data / Function Handling",
              "Example issues to look for": [
                "Invokable Control Element with Excessive File or Data Access Operations",
                "Reliance on Runtime Component in Generated Code",
                "Use of Inherently Dangerous Function",
                "Symbolic Name not Mapping to Correct Object",
                "Use of NullPointerException Catch to Detect NULL Pointer Dereference",
                "Deployment of Wrong Handler",
                "Missing Handler",
                "Use of Function with Inconsistent Implementations",
                "Undefined Behavior for Input to API",
                "Use of Obsolete Function",
                "Exposed Dangerous Method or Function",
                "Improper Control of Generation of Code ('Code Injection')"
              ],
              "Code lines": [
                "Login(username, password string) (cmd *imap.Command, err error)",
                "Logout(timeout time.Duration) (cmd *imap.Command, err error)",
                "Select(name string, readOnly bool) (mbox *imap.MailboxStatus, err error)",
                "Store(seq *imap.SeqSet, item imap.StoreItem, value interface{}, ch chan *imap.Message) (err error)",
                "Fetch(seqset *imap.SeqSet, items []imap.FetchItem, ch chan *imap.Message) (err error)",
                "}",
                "err := s.Validate()",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "s.Host = s.Host + \":\" + strconv.Itoa(int(s.Port)) // Append port",
                "mailServer := Mailbox{",
                "Host:             s.Host,",
                "TLS:              s.TLS,",
                "IgnoreCertErrors: s.IgnoreCertErrors,",
                "User:             s.Username,",
                "Pwd:              s.Password,",
                "Folder:           s.Folder}",
                "imapClient, err := mailServer.newClient()",
                "if err != nil {",
                "log.Error(err.Error())",
                "} else {",
                "imapClient.Logout()",
                "}",
                "return err",
                "}",
                "imapClient, err := mbox.newClient()",
                "if err != nil {",
                "return err",
                "}",
                "defer imapClient.Logout()",
                "seqSet := new(imap.SeqSet)",
                "seqSet.AddNum(seqs...)",
                "item := imap.FormatFlagsOp(imap.RemoveFlags, true)",
                "err = imapClient.Store(seqSet, item, imap.SeenFlag, nil)",
                "if err != nil {",
                "return err",
                "}",
                "return nil",
                "}",
                "// DeleteEmails will delete emails from the supplied slice of SeqNums",
                "imapClient, err := mbox.newClient()",
                "if err != nil {",
                "return err",
                "}",
                "defer imapClient.Logout()",
                "seqSet := new(imap.SeqSet)",
                "seqSet.AddNum(seqs...)",
                "item := imap.FormatFlagsOp(imap.AddFlags, true)",
                "err = imapClient.Store(seqSet, item, imap.DeletedFlag, nil)",
                "if err != nil {",
                "return err",
                "}",
                "return nil",
                "}",
                "// GetUnread will find all unread emails in the folder and return them as a list.",
                "imap.CharsetReader = charset.Reader",
                "var emails []Email",
                "imapClient, err := mbox.newClient()",
                "if err != nil {",
                "return emails, fmt.Errorf(\"failed to create IMAP connection: %s\", err)",
                "}",
                "defer imapClient.Logout()",
                "// Search for unread emails",
                "criteria := imap.NewSearchCriteria()",
                "criteria.WithoutFlags = []string{imap.SeenFlag}",
                "seqs, err := imapClient.Search(criteria)",
                "if err != nil {",
                "return emails, err",
                "}",
                "if len(seqs) == 0 {",
                "return emails, nil",
                "}",
                "seqset := new(imap.SeqSet)",
                "seqset.AddNum(seqs...)",
                "section := &imap.BodySectionName{}",
                "items := []imap.FetchItem{imap.FetchEnvelope, imap.FetchFlags, imap.FetchInternalDate, section.FetchItem()}",
                "messages := make(chan *imap.Message)",
                "go func() {",
                "if err := imapClient.Fetch(seqset, items, messages); err != nil {",
                "log.Error(\"Error fetching emails: \", err.Error()) // TODO: How to handle this, need to propogate error out",
                "}",
                "}()",
                "// Step through each email",
                "for msg := range messages {",
                "// Extract raw message body. I can't find a better way to do this with the emersion library",
                "var em *email.Email",
                "var buf []byte",
                "for _, value := range msg.Body {",
                "buf = make([]byte, value.Len())",
                "value.Read(buf)",
                "break // There should only ever be one item in this map, but I'm not 100% sure",
                "}",
                "//Remove CR characters, see https://github.com/jordan-wright/email/issues/106",
                "tmp := string(buf)",
                "re := regexp.MustCompile(`\\r`)",
                "tmp = re.ReplaceAllString(tmp, \"\")",
                "buf = []byte(tmp)",
                "rawBodyStream := bytes.NewReader(buf)",
                "em, err = email.NewEmailFromReader(rawBodyStream) // Parse with @jordanwright's library",
                "if err != nil {",
                "return emails, err",
                "}",
                "emtmp := Email{Email: em, SeqNum: msg.SeqNum} // Not sure why msg.Uid is always 0, so swapped to sequence numbers",
                "emails = append(emails, emtmp)",
                "}",
                "return emails, nil",
                "}",
                "// newClient will initiate a new IMAP connection with the given creds.",
                "// to implement the mailer.Dialer interface. This allows us to better",
                "// separate the mailer package as opposed to forcing a connection",
                "// between mailer and gomail.",
                "type Dialer struct {",
                "*gomail.Dialer",
                "}",
                "// Dial wraps the gomail dialer's Dial command",
                "func (d *Dialer) Dial() (mailer.Sender, error) {",
                "return d.Dialer.Dial()",
                "}",
                "// SMTP contains the attributes needed to handle the sending of campaign emails",
                "func (s *SMTP) GetDialer() (mailer.Dialer, error) {",
                "// Setup the message and dial",
                "hp := strings.Split(s.Host, \":\")",
                "if len(hp) < 2 {",
                "hp = append(hp, \"25\")",
                "}",
                "host := hp[0]",
                "// Any issues should have been caught in validation, but we'll",
                "// double check here.",
                "port, err := strconv.Atoi(hp[1])",
                "if err != nil {",
                "log.Error(err)",
                "return nil, err",
                "}",
                "d := gomail.NewDialer(host, port, s.Username, s.Password)",
                "d.TLSConfig = &tls.Config{",
                "ServerName:         host,",
                "InsecureSkipVerify: s.IgnoreCertErrors,",
                "}",
                "hostname, err := os.Hostname()",
                "if err != nil {",
                "log.Error(err)",
                "hostname = \"localhost\"",
                "}",
                "d.LocalName = hostname",
                "return &Dialer{d}, err",
                "}",
                "import (",
                "\"bytes\"",
                "\"crypto/hmac\"",
                "\"crypto/sha256\"",
                "\"encoding/hex\"",
                "\"encoding/json\"",
                "\"errors\"",
                "\"fmt\"",
                "\"net/http\"",
                "\"time\"",
                "log \"github.com/gophish/gophish/logger\"",
                ")",
                "Send(endPoint EndPoint, data interface{}) error",
                "}",
                "type defaultSender struct {",
                "client *http.Client",
                "}",
                "var senderInstance = &defaultSender{",
                "client: &http.Client{",
                "Timeout: time.Second * DefaultTimeoutSeconds,",
                "CheckRedirect: func(req *http.Request, via []*http.Request) error {",
                "return http.ErrUseLastResponse",
                "},",
                "},",
                "}",
                "// EndPoint represents a URL to send the webhook to, as well as a secret used",
                "// to sign the event",
                "type EndPoint struct {",
                "URL    string",
                "Secret string",
                "}",
                "// Send sends data to a single EndPoint",
                "return senderInstance.Send(endPoint, data)",
                "}",
                "func SendAll(endPoints []EndPoint, data interface{}) {",
                "for _, e := range endPoints {",
                "go func(e EndPoint) {",
                "senderInstance.Send(e, data)",
                "}(e)",
                "func (ds defaultSender) Send(endPoint EndPoint, data interface{}) error {",
                "jsonData, err := json.Marshal(data)",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "req, err := http.NewRequest(\"POST\", endPoint.URL, bytes.NewBuffer(jsonData))",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "signat, err := sign(endPoint.Secret, jsonData)",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "req.Header.Set(SignatureHeader, fmt.Sprintf(\"%s=%s\", Sha256Prefix, signat))",
                "req.Header.Set(\"Content-Type\", \"application/json\")",
                "resp, err := ds.client.Do(req)",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "defer resp.Body.Close()",
                "if resp.StatusCode >= MinHTTPStatusErrorCode {",
                "errMsg := fmt.Sprintf(\"http status of response: %s\", resp.Status)",
                "log.Error(errMsg)",
                "return errors.New(errMsg)",
                "}",
                "return nil",
                "}",
                "func sign(secret string, data []byte) (string, error) {",
                "hash1 := hmac.New(sha256.New, []byte(secret))",
                "_, err := hash1.Write(data)",
                "if err != nil {",
                "return \"\", err",
                "}",
                "hexStr := hex.EncodeToString(hash1.Sum(nil))",
                "return hexStr, nil",
                "}"
              ]
            },
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Initialization and Cleanup",
              "Example issues to look for": [
                "Initialization of a Resource with an Insecure Default",
                "Non-exit on Failed Initialization"
              ],
              "Code lines": [
                "func (mbox *Mailbox) newClient() (*client.Client, error) {",
                "var imapClient *client.Client",
                "var err error",
                "if mbox.TLS {",
                "config := new(tls.Config)",
                "config.InsecureSkipVerify = mbox.IgnoreCertErrors",
                "imapClient, err = client.DialTLS(mbox.Host, config)",
                "} else {",
                "imapClient, err = client.Dial(mbox.Host)",
                "}",
                "if err != nil {",
                "return imapClient, err",
                "}",
                "err = imapClient.Login(mbox.User, mbox.Pwd)",
                "if err != nil {",
                "return imapClient, err",
                "}",
                "_, err = imapClient.Select(mbox.Folder, mbox.ReadOnly)",
                "if err != nil {",
                "return imapClient, err",
                "}",
                "return imapClient, nil",
                "}",
                "Filename: smtp.go",
                "import (",
                "\"crypto/tls\"",
                "\"errors\"",
                "\"net/mail\"",
                "\"os\"",
                "\"strconv\"",
                "\"strings\"",
                "\"time\"",
                "\"github.com/gophish/gomail\"",
                "log \"github.com/gophish/gophish/logger\"",
                "\"github.com/gophish/gophish/mailer\"",
                "\"github.com/jinzhu/gorm\"",
                ")",
                "// DefaultTimeoutSeconds is the number of seconds before a timeout occurs",
                "// when sending a webhook",
                "DefaultTimeoutSeconds = 10",
                "// MinHTTPStatusErrorCode is the lower bound of HTTP status codes which",
                "// indicate an error occurred",
                "MinHTTPStatusErrorCode = 400",
                "// SignatureHeader is the name of the HTTP header which contains the",
                "// webhook signature",
                "SignatureHeader = \"X-Gophish-Signature\"",
                "// Sha256Prefix is the prefix that specifies the hashing algorithm used",
                "// for the signature",
                "Sha256Prefix = \"sha256\"",
                ")",
                "// Sender represents a type which can send webhooks to an EndPoint"
              ]
            },
            {
              "Primary Functional Area": "Data Management and Integrity",
              "Sub Functional Area": "Data Processing",
              "Example issues to look for": [
                "Data Element Aggregating an Excessively Large Number of Non-Primitive Elements",
                "Excessive Data Query Operations in a Large Data Table",
                "Missing Serialization Control Element",
                "Excessive Execution of Sequential Searches of Data Resource",
                "Data Resource Access without Use of Connection Pooling",
                "Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses",
                "Excessive Index Range Scan for a Data Resource",
                "Reliance on Machine-Dependent Data Representation",
                "Missing XML Validation",
                "Improper Handling of Length Parameter Inconsistency",
                "Collapse of Data into Unsafe Value",
                "Improper Handling of Structural Elements",
                "Acceptance of Extraneous Untrusted Data With Trusted Data",
                "Improper Handling of Highly Compressed Data (Data Amplification)",
                "Deserialization of Untrusted Data",
                "Dangling Database Cursor ('Cursor Injection')"
              ],
              "Code lines": [
                "SeqNum uint32 `json:\"seqnum\"`",
                "*email.Email",
                "}",
                "Id               int64     `json:\"id\" gorm:\"column:id; primary_key:yes\"`",
                "UserId           int64     `json:\"-\" gorm:\"column:user_id\"`",
                "Interface        string    `json:\"interface_type\" gorm:\"column:interface_type\"`",
                "Name             string    `json:\"name\"`",
                "Host             string    `json:\"host\"`",
                "Username         string    `json:\"username,omitempty\"`",
                "Password         string    `json:\"password,omitempty\"`",
                "FromAddress      string    `json:\"from_address\"`",
                "IgnoreCertErrors bool      `json:\"ignore_cert_errors\"`",
                "Headers          []Header  `json:\"headers\"`",
                "ModifiedDate     time.Time `json:\"modified_date\"`",
                "}",
                "// Header contains the fields and methods for a sending profile to have",
                "func GetSMTPs(uid int64) ([]SMTP, error) {",
                "ss := []SMTP{}",
                "err := db.Where(\"user_id=?\", uid).Find(&ss).Error",
                "if err != nil {",
                "log.Error(err)",
                "return ss, err",
                "}",
                "for i := range ss {",
                "err = db.Where(\"smtp_id=?\", ss[i].Id).Find(&ss[i].Headers).Error",
                "if err != nil && err != gorm.ErrRecordNotFound {",
                "log.Error(err)",
                "return ss, err",
                "}",
                "}",
                "return ss, nil",
                "}",
                "func GetSMTP(id int64, uid int64) (SMTP, error) {",
                "s := SMTP{}",
                "err := db.Where(\"user_id=? and id=?\", uid, id).Find(&s).Error",
                "if err != nil {",
                "log.Error(err)",
                "return s, err",
                "}",
                "err = db.Where(\"smtp_id=?\", s.Id).Find(&s.Headers).Error",
                "if err != nil && err != gorm.ErrRecordNotFound {",
                "log.Error(err)",
                "return s, err",
                "}",
                "return s, err",
                "}",
                "func GetSMTPByName(n string, uid int64) (SMTP, error) {",
                "s := SMTP{}",
                "err := db.Where(\"user_id=? and name=?\", uid, n).Find(&s).Error",
                "if err != nil {",
                "log.Error(err)",
                "return s, err",
                "}",
                "err = db.Where(\"smtp_id=?\", s.Id).Find(&s.Headers).Error",
                "if err != nil && err != gorm.ErrRecordNotFound {",
                "log.Error(err)",
                "}",
                "return s, err",
                "}",
                "func PostSMTP(s *SMTP) error {",
                "err := s.Validate()",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "// Insert into the DB",
                "err = db.Save(s).Error",
                "if err != nil {",
                "log.Error(err)",
                "}",
                "// Save custom headers",
                "for i := range s.Headers {",
                "s.Headers[i].SMTPId = s.Id",
                "err := db.Save(&s.Headers[i]).Error",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "}",
                "return err",
                "}",
                "// Per the PUT Method RFC, it presumes all data for a SMTP is provided.",
                "func PutSMTP(s *SMTP) error {",
                "err := s.Validate()",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "err = db.Where(\"id=?\", s.Id).Save(s).Error",
                "if err != nil {",
                "log.Error(err)",
                "}",
                "// Delete all custom headers, and replace with new ones",
                "err = db.Where(\"smtp_id=?\", s.Id).Delete(&Header{}).Error",
                "if err != nil && err != gorm.ErrRecordNotFound {",
                "log.Error(err)",
                "return err",
                "}",
                "// Save custom headers",
                "for i := range s.Headers {",
                "s.Headers[i].SMTPId = s.Id",
                "err := db.Save(&s.Headers[i]).Error",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "}",
                "return err",
                "}",
                "// DeleteSMTP deletes an existing SMTP in the database.",
                "// An error is returned if a SMTP with the given user id and SMTP id is not found.",
                "func DeleteSMTP(id int64, uid int64) error {",
                "// Delete all custom headers",
                "err := db.Where(\"smtp_id=?\", id).Delete(&Header{}).Error",
                "if err != nil {",
                "log.Error(err)",
                "return err",
                "}",
                "err = db.Where(\"user_id=?\", uid).Delete(SMTP{Id: id}).Error",
                "if err != nil {",
                "log.Error(err)",
                "}",
                "return err",
                "}",
                "Filename: webhook.go"
              ]
            },
            {
              "Primary Functional Area": "Data Management and Integrity",
              "Sub Functional Area": "Data Validation",
              "Example issues to look for": [
                "Misinterpretation of Input",
                "Improper Use of Validation Framework",
                "Improper Validation of Unsafe Equivalence in Input",
                "Incorrect Parsing of Numbers with Different Radices",
                "Improper Handling of Missing Special Element",
                "Improper Handling of Additional Special Element",
                "Improper Handling of Inconsistent Special Elements",
                "Improper Handling of Case Sensitivity",
                "Incorrect Behavior Order: Early Validation",
                "Improper Handling of Values",
                "Improper Handling of Parameters",
                "Unchecked Input for Loop Condition"
              ],
              "Code lines": [
                "switch {",
                "case s.FromAddress == \"\":",
                "return ErrFromAddressNotSpecified",
                "case s.Host == \"\":",
                "return ErrHostNotSpecified",
                "}",
                "_, err := mail.ParseAddress(s.FromAddress)",
                "if err != nil {",
                "return err",
                "}",
                "// Make sure addr is in host:port format",
                "hp := strings.Split(s.Host, \":\")",
                "if len(hp) > 2 {",
                "return ErrInvalidHost",
                "} else if len(hp) < 2 {",
                "hp = append(hp, \"25\")",
                "}",
                "_, err = strconv.Atoi(hp[1])",
                "if err != nil {",
                "return ErrInvalidHost",
                "}",
                "return err",
                "}"
              ]
            },
            {
              "Primary Functional Area": "Security and Access Control",
              "Sub Functional Area": "Credentials Management",
              "Example issues to look for": [
                "Use of Default Credentials",
                "Plaintext Storage of a Password",
                "Storing Passwords in a Recoverable Format",
                "Password in Configuration File",
                "Weak Encoding for Password",
                "Not Using Password Aging",
                "Password Aging with Long Expiration",
                "Weak Password Requirements",
                "Unprotected Transport of Credentials",
                "Missing Password Field Masking",
                "Unverified Password Change",
                "Weak Password Recovery Mechanism for Forgotten Password",
                "Use of Hard-coded Credentials",
                "Use of Password Hash Instead of Password for Authentication"
              ],
              "Code lines": [
                "Host             string",
                "TLS              bool",
                "IgnoreCertErrors bool",
                "User             string",
                "Pwd              string",
                "Folder           string",
                "// Read only mode, false (original logic) if not initialized",
                "}"
              ]
            }
          ]
        },
        "scan_response": {
          "vuln_score": 6,
          "exploitable_vuln": true,
          "description": "The code contains several vulnerabilities related to credentials management and data handling. Specifically, the use of plaintext storage for passwords (e.g., 'Pwd' field) poses a significant risk, as it can lead to unauthorized access if the data is compromised. Additionally, the handling of TLS connections with the option to skip certificate verification (e.g., 'InsecureSkipVerify: mbox.IgnoreCertErrors') can expose the application to man-in-the-middle attacks. The code also lacks proper validation for input parameters, which could lead to injection attacks or unexpected behavior. Overall, these issues present a moderate risk of exploitation, especially if the application is deployed in a production environment without proper security measures."
        }
      }
    ]
  },
  {
    "id": "CVE-2022-28948",
    "scan_type": "before",
    "scan_responses": [
      {
        "code_block": {
          "categorized_lines": [
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Expression Issues",
              "Example issues to look for": [
                "Processor Optimization Removal or Modification of Security-critical Code",
                "Excessive Use of Self-Modifying Code",
                "Missing Default Case in Multiple Condition Expression",
                "Use of Incorrect Operator",
                "Incorrect Block Delimitation",
                "Omitted Break Statement in Switch",
                "Reachable Assertion",
                "Executable Regular Expression Error",
                "Permissive Regular Expression",
                "Compiler Optimization Removal or Modification of Security-critical Code",
                "Operator Precedence Logic Error",
                "Loop with Unreachable Exit Condition ('Infinite Loop')"
              ],
              "Code lines": [
                "return p.event.typ",
                "}"
              ]
            },
            {
              "Primary Functional Area": "API and Functionality Management",
              "Sub Functional Area": "Data / Function Handling",
              "Example issues to look for": [
                "Invokable Control Element with Excessive File or Data Access Operations",
                "Reliance on Runtime Component in Generated Code",
                "Use of Inherently Dangerous Function",
                "Symbolic Name not Mapping to Correct Object",
                "Use of NullPointerException Catch to Detect NULL Pointer Dereference",
                "Deployment of Wrong Handler",
                "Missing Handler",
                "Use of Function with Inconsistent Implementations",
                "Undefined Behavior for Input to API",
                "Use of Obsolete Function",
                "Exposed Dangerous Method or Function",
                "Improper Control of Generation of Code ('Code Injection')"
              ],
              "Code lines": [
                "p.fail()",
                "}"
              ]
            }
          ]
        },
        "scan_response": {
          "vuln_score": 6,
          "exploitable_vuln": true,
          "description": "The code contains potential vulnerabilities related to data handling and expression issues. Specifically, the use of 'p.fail()' in the second block could indicate a failure in handling critical operations, which may lead to undefined behavior if not properly managed. Additionally, the return statement 'return p.event.typ' lacks context for error handling or validation, which could lead to security risks if 'p' is not properly validated. These issues could be exploited if an attacker can manipulate the input to these functions, leading to potential denial of service or unexpected behavior."
        }
      }
    ]
  }
]